<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LogAnalyzer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">edu.cuny.hunter.log.tests.report</a> &gt; <a href="../index.html" class="el_bundle">edu.cuny.hunter.log.core</a> &gt; <a href="index.source.html" class="el_package">edu.cuny.hunter.log.core.analysis</a> &gt; <span class="el_source">LogAnalyzer.java</span></div><h1>LogAnalyzer.java</h1><pre class="source lang-java linenums">package edu.cuny.hunter.log.core.analysis;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.MethodInvocation;
import edu.cuny.hunter.log.core.utils.LoggerNames;
import edu.cuny.hunter.log.core.utils.Util;

public class LogAnalyzer extends ASTVisitor {

<span class="fc" id="L20">	private static final Logger LOGGER = Logger.getLogger(LoggerNames.LOGGER_NAME);</span>

<span class="pc" id="L22">	private Set&lt;LogInvocation&gt; logInvocationSet = new HashSet&lt;&gt;();</span>

<span class="fc" id="L24">	private static LinkedList&lt;Float&gt; boundary;</span>

	private boolean test;

<span class="fc" id="L28">	public LogAnalyzer(boolean b) {</span>
<span class="fc" id="L29">		this.test = b;</span>
<span class="fc" id="L30">	}</span>

<span class="nc" id="L32">	public LogAnalyzer() {</span>
<span class="nc" id="L33">	}</span>

	public void analyze() {

		// collect the projects to be analyzed.
<span class="fc" id="L38">		Map&lt;IJavaProject, Set&lt;LogInvocation&gt;&gt; projectToLoggings = this.getLogInvocationSet().stream()</span>
<span class="fc" id="L39">				.collect(Collectors.groupingBy(LogInvocation::getExpressionJavaProject, Collectors.toSet()));</span>

<span class="fc" id="L41">		HashSet&lt;Float&gt; degreeOfInterests = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">		for (LogInvocation logInvocation : this.logInvocationSet) {</span>
<span class="fc" id="L43">			logInvocation.logInfo();</span>
<span class="fc" id="L44">			degreeOfInterests.add(logInvocation.getDegreeOfInterestValue());</span>
		}

		// build boundary
<span class="fc" id="L48">		boundary = buildBoundary(degreeOfInterests);</span>
		// check whether action is needed
<span class="fc bfc" id="L50" title="All 2 branches covered.">		for (LogInvocation logInvocation : this.logInvocationSet)</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">			if (this.doAction(logInvocation))</span>
				// TODO: add more log messages here
<span class="fc" id="L53">				LOGGER.info(&quot;Refactoring happens!&quot;);</span>

<span class="fc" id="L55">	}</span>

	private boolean doAction(LogInvocation logInvocation) {
<span class="fc" id="L58">		Level currentLogLevel = logInvocation.getLogLevel();</span>
<span class="fc" id="L59">		Level suggestedLogLevel = getSuggestedLogLevel(boundary, logInvocation.getDegreeOfInterestValue());</span>

		// TODO: do action here
<span class="fc bfc" id="L62" title="All 2 branches covered.">		if (currentLogLevel == suggestedLogLevel)</span>
<span class="fc" id="L63">			return false;</span>
<span class="pc bpc" id="L64" title="1 of 4 branches missed.">		if (suggestedLogLevel == null || currentLogLevel == null)</span>
<span class="fc" id="L65">			return false;</span>
<span class="fc" id="L66">		return true;</span>
	}

	/**
	 * Get the suggested log level based on boundary.
	 * 
	 * @param boundary
	 * @param DOI
	 * @return the suggested log level
	 */
	private static Level getSuggestedLogLevel(LinkedList&lt;Float&gt; boundary, float DOI) {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">		if (boundary == null)</span>
<span class="nc" id="L78">			return null;</span>
<span class="pc bpc" id="L79" title="2 of 4 branches missed.">		if (DOI &gt;= boundary.get(0) &amp;&amp; DOI &lt; boundary.get(1))</span>
<span class="nc" id="L80">			return Level.FINEST;</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">		if (DOI &lt; boundary.get(2))</span>
<span class="nc" id="L82">			return Level.FINER;</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">		if (DOI &lt; boundary.get(3))</span>
<span class="nc" id="L84">			return Level.FINE;</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">		if (DOI &lt; boundary.get(4))</span>
<span class="nc" id="L86">			return Level.CONFIG;</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">		if (DOI &lt; boundary.get(5))</span>
<span class="nc" id="L88">			return Level.INFO;</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">		if (DOI &lt; boundary.get(6))</span>
<span class="nc" id="L90">			return Level.WARNING;</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">		if (DOI &lt;= boundary.get(7))</span>
<span class="fc" id="L92">			return Level.SEVERE;</span>
<span class="nc" id="L93">		return null;</span>
	}

	/**
	 * Build a list of boundary. The DOI values could be divided into 7 groups by
	 * this boundary. 7 groups are corresponding to 7 logging levels
	 * 
	 * @param degreeOfInterests
	 * @return a list of boundary
	 */
	private LinkedList&lt;Float&gt; buildBoundary(HashSet&lt;Float&gt; degreeOfInterests) {
<span class="fc" id="L104">		float min = getMinDOI(degreeOfInterests);</span>
<span class="fc" id="L105">		float max = getMaxDOI(degreeOfInterests);</span>
<span class="fc" id="L106">		LinkedList&lt;Float&gt; boundary = new LinkedList&lt;&gt;();</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">		if (min &lt;= max) {</span>
<span class="fc" id="L108">			float interval = (max - min) / 7;</span>
<span class="fc" id="L109">			IntStream.range(0, 8).forEach(i -&gt; boundary.add(min + i * interval));</span>
<span class="fc" id="L110">			return boundary;</span>
		} else
<span class="nc" id="L112">			return null;</span>
	}

	/**
	 * Get the minimum of DOIs
	 * 
	 * @param degreeOfInterests
	 */
	private float getMinDOI(HashSet&lt;Float&gt; degreeOfInterests) {
<span class="fc" id="L121">		float min = Float.MAX_VALUE;</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">		for (float d : degreeOfInterests)</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">			if (d &lt; min)</span>
<span class="fc" id="L124">				min = d;</span>
<span class="fc" id="L125">		return min;</span>
	}

	private float getMaxDOI(HashSet&lt;Float&gt; degreeOfInterests) {
<span class="fc" id="L129">		float max = Float.MIN_VALUE;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">		for (float d : degreeOfInterests)</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">			if (d &gt; max)</span>
<span class="nc" id="L132">				max = d;</span>
<span class="fc" id="L133">		return max;</span>
	}

	public Set&lt;LogInvocation&gt; getLogInvocationSet() {
<span class="fc" id="L137">		return this.logInvocationSet;</span>
	}

	public void setTest(boolean test) {
<span class="nc" id="L141">		this.test = test;</span>
<span class="nc" id="L142">	}</span>

	/**
	 * This method is used to find a set of logging objects
	 */
	@Override
	public boolean visit(MethodInvocation node) {

<span class="fc" id="L150">		Level logLevel = null;</span>

		try {
<span class="fc" id="L153">			logLevel = Util.isLogExpression(node, test);</span>
<span class="fc" id="L154">		} catch (IllegalStateException e) {</span>
<span class="fc" id="L155">			LOGGER.warning(&quot;Need to process the variable of logging level or LogRecord!&quot;);</span>
<span class="fc" id="L156">			createLogInvocation(node, null);</span>
		}

<span class="fc bfc" id="L159" title="All 2 branches covered.">		if (logLevel != null)</span>
<span class="fc" id="L160">			createLogInvocation(node, logLevel);</span>

<span class="fc" id="L162">		return super.visit(node);</span>
	}

	private void createLogInvocation(MethodInvocation node, Level logLevel) {
<span class="fc" id="L166">		LogInvocation logInvocation = new LogInvocation(node, logLevel);</span>
<span class="fc" id="L167">		this.getLogInvocationSet().add(logInvocation);</span>
<span class="fc" id="L168">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>